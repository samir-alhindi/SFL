
import "lib\\std.sfl"

data Expre =
      Number n
    | Binary opp e1 e2
    | Unary opp e
    | Name s
    | Let name e1 e2 -- let x = 5 in x * 2
    | Lambda parameters body closure -- \ x y -> x + y
    | Apply lambda args;

enum BinaryOpp = Plus | Minus | Multiply | Divide
enum UnaryOpp  = Negation

data Environment = Environment table outer | Global table;

find name envi =
    let p = (\ name pair -> name == !pair) in
        match envi with
            case Global table            -> let results = (filter (p >< name) table) in
                                            if is_empty results
                                                then Left ("unbound name: " + name)
                                                else Right (last (!results))
            case Environment table outer -> let results = (filter (p >< name) table) in
                                            if is_empty results
                                                then find name outer
                                                else Right (last (!results))
            else -> Left "Please enter an environment.";

extend_envi envi pair = match envi with
    case Environment table outer -> Environment (pair:table) outer
    case Global table            -> Global (pair:table)
    else                         -> "Please enter an environment.";

eval envi expre = match expre with
    case Number n           ->  Right n
    case Binary opp e1 e2   ->  (eval envi e1) >>= \ v1 ->
                                (eval envi e2) >>= \ v2 ->
                                match opp with
                                    case Plus     -> Right (v1 + v2)
                                    case Minus    -> Right (v1 - v2)
                                    case Multiply -> Right (v1 * v2)
                                    case Divide   -> if v2 == 0 then Left ("Cannot divide by 0") else v1 / v2
                                    else          -> Left "Invalid binary opperator."
    case Unary opp e        ->  (eval envi e) >>= \ v ->
                                match opp with
                                    case Negation -> Right (-v)
                                    else          -> Left "Inavlid unary opperator."
    
    case Name s             -> find s envi

    case Let name e1 e2     ->  (eval envi e1) >>= \ v1 -> 
                                let new_envi = extend_envi envi [name, v1]
                                in eval new_envi e2
    
    case Lambda p b c       -> Lambda p b c

    case Apply lambda args   -> match lambda with
                                case Lambda params body closure -> if (len params) != (len args)
                                                                    then Left ("Expected an arity of " + (len params))
                                                                    else (mapM (eval >< envi) args) >>= \ values ->
                                                                         let pairs = zip params values in
                                                                         let new_envi = Environment pairs closure in
                                                                         eval new_envi body
                                                                         
                                                                        

                                else -> Left "Can only apply lambdas."

    else                    -> Left "is Inavlid expression type.";


tests = [
    Number 1, -- 1

    Binary Plus (Number 5) (Number 6), -- 5 + 6
    Binary Multiply (Number 10) (Number 2), -- 10 * 2
    Binary Minus (Number 5) (Number 10), -- 5 - 10
    Binary Divide (Number 5) (Number 2), -- 5 / 2

    Unary Negation (Number 3), -- -3
    Unary Negation (Unary Negation (Number 5)), -- --5

    Binary Plus (Number 1) (Binary Multiply (Number 2) (Number 3)), -- 1 + 2 * 3
    Unary Negation ( Binary Divide (Number 6) (Number 0)) -- -(6 / 2)
    ];


test_envi = Global [];
print map (eval >< test_envi) tests;

test_envi_2 = Environment [["x", 5]] test_envi;
print eval test_envi_2 (Binary Plus (Name "x") (Number 1));

test_envi_3 = Environment [["x", 10], ["x", 15]] test_envi_2;
print eval test_envi_3 (Name "x");

test_envi_4 = Environment [] (Global [["num", 18]]);
print eval test_envi_4 (Name "num");

print eval test_envi_3 (Let "x" (Number 5) (Binary Plus (Name "x") (Number 2)));

lambda = Lambda ["x", "y"] (Binary Plus (Name "x") (Name "y")) test_envi;
application = Apply lambda [Number 2, Number 3];
print eval test_envi application;


currey = Lambda ["x"] (Lambda ["y"] (Binary Plus (Name "x") (Name "y")) ) test_envi;