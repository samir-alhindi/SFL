
import "lib\\std.sfl"

data Expre =
      Number n
    | Binary opp e1 e2
    | Unary opp e
    | Name s
    | Let name e1 e2 -- let x = 5 in x * 2
    | Lambda parameters body closure -- \ x y -> x + y
    | Apply lambda args;

enum BinaryOpp = Plus | Minus | Multiply | Divide
enum UnaryOpp  = Negation

data Environment = Environment table outer | Global table;

global = Global ([Pair "x" 5]);

find name envi =
    let p = (\ name pair -> name == key pair) in
        match envi with
            case Global table            -> let results = (filter (p >< name) table) in
                                            if is_empty results
                                                then Left ("unbound name: " + name)
                                                else Right (last (!results))
            case Environment table outer -> let results = (filter (p >< name) table) in
                                            if is_empty results
                                                then find name outer
                                                else Right (last (!results))
            else -> Left "Please enter an environment.";

extend_envi envi pair = match envi with
    case Environment table outer -> Environment (pair:table) outer
    case Global table            -> Global (pair:table)
    else                         -> "Please enter an environment.";

eval envi expre = match expre with
    case Number n           ->  Right n
    case Binary opp e1 e2   ->  (eval envi e1) >>= \ v1 ->
                                (eval envi e2) >>= \ v2 ->
                                match opp with
                                    case Plus     -> Right (v1 + v2)
                                    case Minus    -> Right (v1 - v2)
                                    case Multiply -> Right (v1 * v2)
                                    case Divide   -> if v2 == 0 then Left ("Cannot divide by 0") else v1 / v2
                                    else          -> Left "Invalid binary opperator."
    case Unary opp e        ->  (eval envi e) >>= \ v ->
                                match opp with
                                    case Negation -> Right (-v)
                                    else          -> Left "Inavlid unary opperator."
    
    case Name s             -> find s envi

    case Let name e1 e2     ->  (eval envi e1) >>= \ v1 -> 
                                let new_envi = extend_envi envi [name, v1]
                                in eval new_envi e2
    
    case Lambda p b c       -> Lambda p b c

    case Apply lambda args   -> match lambda with
                                case Lambda params body closure -> if (len params) != (len args)
                                                                    then Left ("Expected an arity of " + (len params))
                                                                    else (mapM (eval >< envi) args) >>= \ values ->
                                                                         let pairs = zip params values in
                                                                         let new_envi = Environment pairs closure in
                                                                         eval new_envi body
                                                                         
                                                                        

                                else -> Left "Can only apply lambdas."

    else                    -> Left "is Inavlid expression type.";